// Take schema from https://github.com/anchore/syft/tree/main/schema/json.
// Match version to tag used i.e. https://github.com/anchore/syft/blob/v1.37.0/internal/constants.go#L6
// Can convert JSON Schema to C# using quicktype.io.
// (change name of top Coordinate class to SyftOutput)
// <auto-generated />

#nullable enable
#pragma warning disable CS8618
#pragma warning disable CS8601
#pragma warning disable CS8603
namespace Microsoft.ComponentDetection.Detectors.Linux.Contracts;

using System;
using System.Collections.Generic;

using System.Text.Json;
using System.Text.Json.Serialization;
using System.Globalization;

/// <summary>
/// Document represents the syft cataloging findings as a JSON document
/// </summary>
public partial class SyftOutput
{
    [JsonPropertyName("artifactRelationships")]
    public ArtifactRelationshipElement[] ArtifactRelationships { get; set; }

    [JsonPropertyName("artifacts")]
    public ArtifactElement[] Artifacts { get; set; }

    [JsonPropertyName("descriptor")]
    public Descriptor Descriptor { get; set; }

    [JsonPropertyName("distro")]
    public Distro Distro { get; set; }

    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("files")]
    public FileElement[] Files { get; set; }

    [JsonPropertyName("schema")]
    public Schema Schema { get; set; }

    [JsonPropertyName("source")]
    public SourceClass Source { get; set; }
}

public partial class ArtifactRelationshipElement
{
    [JsonPropertyName("child")]
    public string Child { get; set; }

    [JsonPropertyName("metadata")]
    public object Metadata { get; set; }

    [JsonPropertyName("parent")]
    public string Parent { get; set; }

    [JsonPropertyName("type")]
    public string Type { get; set; }
}

/// <summary>
/// Package represents a pkg.Package object specialized for JSON marshaling and unmarshalling.
/// </summary>
public partial class ArtifactElement
{
    [JsonPropertyName("cpes")]
    public CpeElement[] Cpes { get; set; }

    [JsonPropertyName("foundBy")]
    public string FoundBy { get; set; }

    [JsonPropertyName("id")]
    public string Id { get; set; }

    [JsonPropertyName("language")]
    public string Language { get; set; }

    [JsonPropertyName("licenses")]
    public ArtifactLicense[] Licenses { get; set; }

    [JsonPropertyName("locations")]
    public LocationElement[] Locations { get; set; }

    [JsonPropertyName("metadata")]
    public MetadataClass Metadata { get; set; }

    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("metadataType")]
    public string MetadataType { get; set; }

    [JsonPropertyName("name")]
    public string Name { get; set; }

    [JsonPropertyName("purl")]
    public string Purl { get; set; }

    [JsonPropertyName("type")]
    public string Type { get; set; }

    [JsonPropertyName("version")]
    public string Version { get; set; }
}

public partial class CpeElement
{
    [JsonPropertyName("cpe")]
    public string Cpe { get; set; }

    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("source")]
    public string Source { get; set; }
}

public partial class ArtifactLicense
{
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("contents")]
    public string Contents { get; set; }

    [JsonPropertyName("locations")]
    public LocationElement[] Locations { get; set; }

    [JsonPropertyName("spdxExpression")]
    public string SpdxExpression { get; set; }

    [JsonPropertyName("type")]
    public string Type { get; set; }

    [JsonPropertyName("urls")]
    public string[] Urls { get; set; }

    [JsonPropertyName("value")]
    public string Value { get; set; }
}

/// <summary>
/// Location represents a path relative to a particular filesystem resolved to a specific
/// file.Reference.
/// </summary>
public partial class LocationElement
{
    /// <summary>
    /// AccessPath is the path used to retrieve file contents (which may or may not have
    /// hardlinks / symlinks in the path)
    /// </summary>
    [JsonPropertyName("accessPath")]
    public string AccessPath { get; set; }

    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("annotations")]
    public Dictionary<string, string> Annotations { get; set; }

    /// <summary>
    /// FileSystemID is an ID representing and entire filesystem. For container images, this is a
    /// layer digest. For directories or a root filesystem, this is blank.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("layerID")]
    public string LayerId { get; set; }

    /// <summary>
    /// RealPath is the canonical absolute form of the path accessed (all symbolic links have
    /// been followed and relative path components like '.' and '..' have been removed).
    /// </summary>
    [JsonPropertyName("path")]
    public string Path { get; set; }
}

/// <summary>
/// AlpmDBEntry is a struct that represents the package data stored in the pacman flat-file
/// stores for arch linux.
///
/// ApkDBEntry represents all captured data for the alpine linux package manager flat-file
/// store.
///
/// BinarySignature represents a set of matched values within a binary file.
///
/// BitnamiSBOMEntry represents all captured data from Bitnami packages described in Bitnami'
/// SPDX files.
///
/// ConanfileEntry represents a single "Requires" entry from a conanfile.txt.
///
/// ConaninfoEntry represents a single "full_requires" entry from a conaninfo.txt.
///
/// ConanV1LockEntry represents a single "node" entry from a conan.lock V1 file.
///
/// ConanV2LockEntry represents a single "node" entry from a conan.lock V2 file.
///
/// CocoaPodfileLockEntry represents a single entry from the "Pods" section of a Podfile.lock
/// file.
///
/// CondaMetaPackage represents metadata for a Conda package extracted from the
/// conda-meta/*.json files.
///
/// DartPubspec is a struct that represents a package described in a pubspec.yaml file
///
/// DartPubspecLockEntry is a struct that represents a single entry found in the "packages"
/// section in a Dart pubspec.lock file.
///
/// DotnetDepsEntry is a struct that represents a single entry found in the "libraries"
/// section in a .NET [*.]deps.json file.
///
/// DotnetPackagesLockEntry is a struct that represents a single entry found in the
/// "dependencies" section in a .NET packages.lock.json file.
///
/// DotnetPortableExecutableEntry is a struct that represents a single entry found within
/// "VersionResources" section of a .NET Portable Executable binary file.
///
/// DpkgArchiveEntry represents package metadata extracted from a .deb archive file.
///
/// DpkgDBEntry represents all captured data for a Debian package DB entry; available fields
/// are described at http://manpages.ubuntu.com/manpages/xenial/man1/dpkg-query.1.html in the
/// --showformat section.
///
/// ELFBinaryPackageNoteJSONPayload Represents metadata captured from the .note.package
/// section of an ELF-formatted binary
///
/// ElixirMixLockEntry is a struct that represents a single entry in a mix.lock file
///
/// ErlangRebarLockEntry represents a single package entry from the "deps" section within an
/// Erlang rebar.lock file.
///
/// GitHubActionsUseStatement represents a single 'uses' statement in a GitHub Actions
/// workflow file referencing an action or reusable workflow.
///
/// GolangBinaryBuildinfoEntry represents all captured data for a Golang binary
///
/// GolangModuleEntry represents all captured data for a Golang source scan with
/// go.mod/go.sum
///
/// GolangSourceEntry represents all captured data for a Golang package found through source
/// analysis
///
/// HackageStackYamlEntry represents a single entry from the "extra-deps" section of a
/// stack.yaml file.
///
/// HackageStackYamlLockEntry represents a single entry from the "packages" section of a
/// stack.yaml.lock file.
///
/// HomebrewFormula represents metadata about a Homebrew formula package extracted from
/// formula JSON files.
///
/// JavaArchive encapsulates all Java ecosystem metadata for a package as well as an
/// (optional) parent relationship.
///
/// JavaVMInstallation represents a Java Virtual Machine installation discovered on the
/// system with its release information and file list.
///
/// NpmPackage represents the contents of a javascript package.json file.
///
/// NpmPackageLockEntry represents a single entry within the "packages" section of a
/// package-lock.json file.
///
/// YarnLockEntry represents a single entry section of a yarn.lock file.
///
/// LinuxKernel represents all captured data for a Linux kernel
///
/// LinuxKernelModule represents a loadable kernel module (.ko file) with its metadata,
/// parameters, and dependencies.
///
/// LuaRocksPackage represents a Lua package managed by the LuaRocks package manager with
/// metadata from .rockspec files.
///
/// MicrosoftKbPatch is slightly odd in how it is expected to map onto data.
///
/// NixStoreEntry represents a package in the Nix store (/nix/store) with its derivation
/// information and metadata.
///
/// OpamPackage represents an OCaml package managed by the OPAM package manager with metadata
/// from .opam files.
///
/// PEBinary represents metadata captured from a Portable Executable formatted binary (dll,
/// exe, etc.)
///
/// PhpComposerInstalledEntry represents a single package entry from a composer v1/v2
/// "installed.json" files (very similar to composer.lock files).
///
/// PhpComposerLockEntry represents a single package entry found from a composer.lock file.
///
/// PhpPearEntry represents a single package entry found within php pear metadata files.
///
/// PhpPeclEntry represents a single package entry found within php pecl metadata files.
///
/// PortageEntry represents a single package entry in the portage DB flat-file store.
///
/// PythonPackage represents all captured data for a python egg or wheel package
/// (specifically as outlined in the PyPA core metadata specification
/// https://packaging.python.org/en/latest/specifications/core-metadata/).
///
/// PythonPdmLockEntry represents a single package entry within a pdm.lock file.
///
/// PythonRequirementsEntry represents a single entry within a [*-]requirements.txt file.
///
/// PythonPipfileLockEntry represents a single package entry within a Pipfile.lock file.
///
/// PythonPoetryLockEntry represents a single package entry within a Pipfile.lock file.
///
/// PythonUvLockEntry represents a single package entry within a uv.lock file.
///
/// RDescription represents metadata from an R package DESCRIPTION file containing package
/// information, dependencies, and author details.
///
/// RpmArchive represents package metadata extracted directly from a .rpm archive file,
/// containing the same information as an RPM database entry.
///
/// RpmDBEntry represents all captured data from a RPM DB package entry.
///
/// RubyGemspec represents all metadata parsed from the *.gemspec file
///
/// RustBinaryAuditEntry represents Rust crate metadata extracted from a compiled binary
/// using cargo-auditable format.
///
/// RustCargoLockEntry represents a locked dependency from a Cargo.lock file with precise
/// version and checksum information.
///
/// SnapEntry represents metadata for a Snap package extracted from snap.yaml or
/// snapcraft.yaml files.
///
/// SwiftPackageManagerResolvedEntry represents a resolved dependency from a Package.resolved
/// file with its locked version and source location.
///
/// SwiplPackEntry represents a SWI-Prolog package from the pack system with metadata about
/// the package and its dependencies.
///
/// TerraformLockProviderEntry represents a single provider entry in a Terraform dependency
/// lock file (.terraform.lock.hcl).
///
/// WordpressPluginEntry represents all metadata parsed from the wordpress plugin file
/// </summary>
public partial class MetadataClass
{
    /// <summary>
    /// Architecture is the target CPU architecture as defined in Arch architecture spec (e.g.
    /// x86_64, aarch64, or "any" for arch-independent packages)
    ///
    /// Architecture is the target CPU architecture
    ///
    /// Architecture is the target architecture per Debian spec (specific arch like amd64/arm64,
    /// wildcard like any, architecture-independent "all", or "source" for source packages)
    ///
    /// Architecture of the binary package (e.g. "amd64", "arm", etc.)
    ///
    /// Architecture is the target CPU architecture for the binary (extracted from GOARCH build
    /// setting).
    ///
    /// Architecture is the target CPU architecture for build constraints (e.g., "amd64",
    /// "arm64").
    ///
    /// Arch is the target CPU architecture (e.g., "x86_64", "aarch64", "noarch").
    ///
    /// Architecture is the target CPU architecture (e.g., "amd64", "arm64").
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("architecture")]
    public string Architecture { get; set; }

    /// <summary>
    /// Backup is the list of configuration files that pacman backs up before upgrades
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("backup")]
    public BackupElement[] Backup { get; set; }

    /// <summary>
    /// BasePackage is the base package name this package was built from (source package in Arch
    /// build system)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("basepackage")]
    public string Basepackage { get; set; }

    /// <summary>
    /// Depends are the runtime dependencies required by this package
    ///
    /// Depends is the list of runtime dependencies with version constraints.
    ///
    /// Depends are the packages required for this package to function (will not be installed
    /// unless these requirements are met, creates strict ordering constraint)
    ///
    /// Depends are the packages this package depends on
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("depends")]
    public string[] Depends { get; set; }

    /// <summary>
    /// Description is a human-readable package description
    ///
    /// Description is a human-readable formula description
    ///
    /// Description is a human-readable module description
    ///
    /// Description is detailed package description
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("description")]
    public string Description { get; set; }

    /// <summary>
    /// Files are the files installed by this package
    ///
    /// Files are the file paths owned by this package (tracked via SPDX relationships)
    ///
    /// Files is the list of files installed by this package.
    ///
    /// Files are the list of files that are part of this JVM installation
    ///
    /// Files are the list of files under the nix/store path for this package
    ///
    /// Files are the files installed by this package (tracked in CONTENTS file)
    ///
    /// Files are the installed files listed in the RECORD file for wheels or installed-files.txt
    /// for eggs.
    ///
    /// Files are the package files with their paths and hash digests
    ///
    /// Files are the file records for all files owned by this package.
    ///
    /// Files is logical list of files in the gem (NOT directly usable as filesystem paths.
    /// Example: bundler gem lists "lib/bundler/vendor/uri/lib/uri/ldap.rb" but actual path is
    /// "/usr/local/lib/ruby/3.2.0/bundler/vendor/uri/lib/uri/ldap.rb". Would need gem
    /// installation path, ruby version, and env vars like GEM_HOME to resolve actual paths.)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("files")]
    public File[] Files { get; set; }

    /// <summary>
    /// Package is the package name as found in the desc file
    ///
    /// Package is the package name as found in the installed file
    ///
    /// Package is the package name as found in the status file
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("package")]
    public string Package { get; set; }

    /// <summary>
    /// Packager is the name and email of the person who packaged this (RFC822 format)
    ///
    /// Packager is packager name (if different from author)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("packager")]
    public string Packager { get; set; }

    /// <summary>
    /// Provides are virtual packages provided by this package (allows other packages to depend
    /// on capabilities rather than specific packages)
    ///
    /// Provides are virtual packages provided by this package (for capability-based
    /// dependencies)
    ///
    /// Provides are the virtual packages provided by this package (allows other packages to
    /// depend on capabilities. Can include versioned provides like "libdigest-md5-perl (=
    /// 2.55.01)")
    ///
    /// Provides lists the virtual packages and capabilities this package provides.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("provides")]
    public string[] Provides { get; set; }

    /// <summary>
    /// Reason is the installation reason tracked by pacman (0=explicitly installed by user,
    /// 1=installed as dependency)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("reason")]
    public long? Reason { get; set; }

    /// <summary>
    /// Size is the installed size in bytes
    ///
    /// Size is the package archive size in bytes (.apk file size)
    ///
    /// Size is the package archive size in bytes.
    ///
    /// Size is the total installed size of the package in bytes.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("size")]
    public long? Size { get; set; }

    /// <summary>
    /// URL is the upstream project URL
    ///
    /// URL is the full download URL for the package archive.
    ///
    /// URL is repository or project URL
    ///
    /// URL is the source download URL
    ///
    /// URL is download URL for the package source
    ///
    /// URL is the direct download URL or VCS URL if specified instead of a PyPI package.
    ///
    /// URL is the list of related URLs
    ///
    /// URL is the provider source address (e.g., "registry.terraform.io/hashicorp/aws").
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("url")]
    public Checksum? Url { get; set; }

    /// <summary>
    /// Validation is the validation method used for package integrity (e.g. pgp signature,
    /// sha256 checksum)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("validation")]
    public string Validation { get; set; }

    /// <summary>
    /// Version is the package version as found in the desc file
    ///
    /// Version is the package version as found in the installed file
    ///
    /// Version is the package version as found in the Bitnami SPDX file
    ///
    /// Version is the package version as found in the conda-meta JSON file.
    ///
    /// Version is the package version as found in the pubspec.lock file
    ///
    /// Version is the package version as found in the deps.json file
    ///
    /// Version is the package version as found in the packages.lock.json file
    ///
    /// Version is the binary package version as found in the status file
    ///
    /// Version is the package version as found in the mix.lock file
    ///
    /// Version is the package version as found in the rebar.lock file
    ///
    /// Version is the package version as found in package.json
    ///
    /// Version is kernel version string
    ///
    /// Version is module version string
    ///
    /// Version is the package version as found in the .rockspec file
    ///
    /// Version is the package version as found in the .opam file
    ///
    /// Version is the package version
    ///
    /// Version is the package version from the Version field in PKG-INFO or METADATA.
    ///
    /// Version is the upstream version of the package.
    ///
    /// Version is gem version as specified in the gemspec
    ///
    /// Version is crate version as specified in audit section of the build binary
    ///
    /// Version is crate version as specified in Cargo.toml
    ///
    /// Version is the package version as found in the .toml file
    ///
    /// Version is the locked provider version selected during terraform init.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("version")]
    public string Version { get; set; }

    /// <summary>
    /// GitCommit is the git commit hash of the APK port definition in Alpine's aports repository
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("gitCommitOfApkPort")]
    public string GitCommitOfApkPort { get; set; }

    /// <summary>
    /// InstalledSize is the total size of installed files in bytes
    ///
    /// InstalledSize is the total size of installed files in kilobytes
    ///
    /// InstalledSize is total size of installed files in bytes
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("installedSize")]
    public long? InstalledSize { get; set; }

    /// <summary>
    /// Maintainer is the package maintainer name and email
    ///
    /// Maintainer is the package maintainer's name and email in RFC822 format (name must come
    /// first, then email in angle brackets)
    ///
    /// Maintainer is current package maintainer
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("maintainer")]
    public string Maintainer { get; set; }

    /// <summary>
    /// OriginPackage is the original source package name this binary was built from (used to
    /// track which aport/source built this)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("originPackage")]
    public string OriginPackage { get; set; }

    /// <summary>
    /// Checksum is the package content checksum for integrity verification
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("pullChecksum")]
    public string PullChecksum { get; set; }

    /// <summary>
    /// Dependencies are the runtime dependencies required by this package
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("pullDependencies")]
    public string[] PullDependencies { get; set; }

    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("matches")]
    public MatchElement[] Matches { get; set; }

    /// <summary>
    /// Architecture is the target CPU architecture (amd64 or arm64 in Bitnami images)
    ///
    /// Arch is the target CPU architecture for the package (e.g., "arm64", "x86_64").
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("arch")]
    public string Arch { get; set; }

    /// <summary>
    /// Distro is the distribution name this package is for (base OS like debian, ubuntu, etc.)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("distro")]
    public string Distro { get; set; }

    /// <summary>
    /// Name is the package name as found in the Bitnami SPDX file
    ///
    /// Name is the package name as found in the conda-meta JSON file.
    ///
    /// Name is the package name as found in the pubspec.lock file
    ///
    /// Name is the package name as found in the deps.json file
    ///
    /// Name is the package name as found in the packages.lock.json file
    ///
    /// Name is the package name as found in the mix.lock file
    ///
    /// Name is the package name as found in the rebar.lock file
    ///
    /// Name is the package name as found in package.json
    ///
    /// Name is kernel name (typically "Linux")
    ///
    /// Name is module name
    ///
    /// Name is the package name as found in the .rockspec file
    ///
    /// Name is the package name as found in the .opam file
    ///
    /// Name is package name in vendor/package format (e.g. symfony/console)
    ///
    /// Name is the package name
    ///
    /// Name is the package name from the Name field in PKG-INFO or METADATA.
    ///
    /// Name is the package name from the requirements file.
    ///
    /// Name is the RPM package name as found in the RPM database.
    ///
    /// Name is gem name as specified in the gemspec
    ///
    /// Name is crate name as specified in audit section of the build binary
    ///
    /// Name is crate name as specified in Cargo.toml
    ///
    /// Name is the package name as found in the .toml file
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("name")]
    public string Name { get; set; }

    /// <summary>
    /// Path is the installation path in the filesystem where the package is located
    ///
    /// Path is the filesystem path to the package in Conan cache
    ///
    /// Path is the relative path to the package within the deps structure (e.g.
    /// "app.metrics/3.0.0")
    ///
    /// Path is the filesystem path to the .ko kernel object file (absolute path)
    ///
    /// Path is full store path for this output (e.g. /nix/store/abc123...-package-1.0)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("path")]
    public string Path { get; set; }

    /// <summary>
    /// Revision is the Bitnami-specific package revision number (incremented for Bitnami
    /// rebuilds of same upstream version)
    ///
    /// Revision is git commit hash of the resolved package
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("revision")]
    public string Revision { get; set; }

    /// <summary>
    /// Ref is the package reference string in format name/version@user/channel
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("ref")]
    public string Ref { get; set; }

    /// <summary>
    /// PackageID is a unique package variant identifier
    ///
    /// PackageID is a unique package variant identifier computed from settings/options (static
    /// hash in Conan 1.x, can have collisions with complex dependency graphs)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("package_id")]
    public string SyftOutputPackageId { get; set; }

    /// <summary>
    /// BuildRequires are the build-time dependencies (e.g. cmake, compilers)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("build_requires")]
    public string[] BuildRequires { get; set; }

    /// <summary>
    /// Context is the build context information
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("context")]
    public string Context { get; set; }

    /// <summary>
    /// Options are package configuration options as key-value pairs (e.g. shared=True, fPIC=True)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("options")]
    public VersionResourceElement[] Options { get; set; }

    /// <summary>
    /// Prev is the previous lock entry reference for versioning
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("prev")]
    public string Prev { get; set; }

    /// <summary>
    /// PythonRequires are the Python dependencies needed for Conan recipes
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("py_requires")]
    public string[] PyRequires { get; set; }

    /// <summary>
    /// Requires are the runtime package dependencies
    ///
    /// Requires lists the dependencies required by this package.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("requires")]
    public string[] Requires { get; set; }

    /// <summary>
    /// Channel is the Conan channel name indicating stability/purpose (e.g. stable, testing,
    /// experimental)
    ///
    /// Channel is the Conda channel URL where the package was retrieved from.
    ///
    /// Channel is PEAR channel this package is from
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("channel")]
    public string Channel { get; set; }

    /// <summary>
    /// PackageID is a unique package variant identifier (dynamic in Conan 2.0, more accurate
    /// than V1)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("packageID")]
    public string PackageId { get; set; }

    /// <summary>
    /// PackageRevision is a git-like revision hash of the built binary package
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("packageRevision")]
    public string PackageRevision { get; set; }

    /// <summary>
    /// RecipeRevision is a git-like revision hash (RREV) of the recipe
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("recipeRevision")]
    public string RecipeRevision { get; set; }

    /// <summary>
    /// TimeStamp is when this package was built/locked
    ///
    /// Timestamp is the Unix timestamp when the package was built.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("timestamp")]
    public Timestamp? Timestamp { get; set; }

    /// <summary>
    /// Username is the Conan user/organization name
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("username")]
    public string Username { get; set; }

    /// <summary>
    /// Checksum is the SHA-1 hash of the podspec file for integrity verification (generated via
    /// `pod ipc spec ... | openssl sha1`), ensuring all team members use the same pod
    /// specification version
    ///
    /// Checksums are the list of checksums for verification
    ///
    /// Checksum is content checksum for registry packages only (hexadecimal string). Cargo
    /// doesn't require or include checksums for git dependencies. Used to detect MITM attacks by
    /// verifying downloaded crate matches lockfile checksum.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("checksum")]
    public Checksum? Checksum { get; set; }

    /// <summary>
    /// Build is the build string identifier (e.g., "h90dfc92_1014").
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("build")]
    public string Build { get; set; }

    /// <summary>
    /// BuildNumber is the sequential build number for this version.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("build_number")]
    public long? BuildNumber { get; set; }

    /// <summary>
    /// ExtractedPackageDir is the local cache directory where the package was extracted.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("extracted_package_dir")]
    public string ExtractedPackageDir { get; set; }

    /// <summary>
    /// Filename is the original package archive filename (e.g.,
    /// "zlib-1.2.11-h90dfc92_1014.tar.bz2").
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("fn")]
    public string Fn { get; set; }

    /// <summary>
    /// License is the package license identifier.
    ///
    /// License is module license (e.g. GPL, BSD) which must be compatible with kernel
    ///
    /// License is license identifier
    ///
    /// License is the list of license identifiers (SPDX format)
    ///
    /// License is the list of applicable licenses
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("license")]
    public Checksum? License { get; set; }

    /// <summary>
    /// LicenseFamily is the general license category (e.g., "MIT", "Apache", "GPL").
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("license_family")]
    public string LicenseFamily { get; set; }

    /// <summary>
    /// Link contains installation source metadata from the link.json file.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("link")]
    public Link Link { get; set; }

    /// <summary>
    /// MD5 is the MD5 hash of the package archive.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("md5")]
    public string Md5 { get; set; }

    /// <summary>
    /// Noarch indicates if the package is platform-independent (e.g., "python", "generic").
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("noarch")]
    public string Noarch { get; set; }

    /// <summary>
    /// PathsData contains detailed file metadata from the paths.json file.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("paths_data")]
    public PathsData PathsData { get; set; }

    /// <summary>
    /// SHA256 is the SHA-256 hash of the package archive.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("sha256")]
    public string Sha256 { get; set; }

    /// <summary>
    /// Subdir is the subdirectory within the channel (e.g., "osx-arm64", "linux-64").
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("subdir")]
    public string Subdir { get; set; }

    /// <summary>
    /// Documentation is the documentation site URL
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("documentation")]
    public string Documentation { get; set; }

    /// <summary>
    /// Environment is SDK version constraints for Dart and Flutter
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("environment")]
    public Environment Environment { get; set; }

    /// <summary>
    /// Homepage is the package homepage URL
    ///
    /// Homepage is the upstream project homepage URL
    ///
    /// Homepage is project homepage URL
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("homepage")]
    public string Homepage { get; set; }

    /// <summary>
    /// IgnoredAdvisories are the security advisories to explicitly ignore for this package
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("ignored_advisories")]
    public string[] IgnoredAdvisories { get; set; }

    /// <summary>
    /// Platforms are the supported platforms (Android, iOS, web, etc.)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("platforms")]
    public string[] Platforms { get; set; }

    /// <summary>
    /// PublishTo is the package repository to publish to, or "none" to prevent accidental
    /// publishing
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("publish_to")]
    public string PublishTo { get; set; }

    /// <summary>
    /// Repository is the source code repository URL
    ///
    /// Repository is CRAN or other repository name
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("repository")]
    public string Repository { get; set; }

    /// <summary>
    /// HostedURL is the URL of the package repository for hosted packages (typically pub.dev,
    /// but can be custom repository identified by hosted-url). When PUB_HOSTED_URL environment
    /// variable changes, lockfile tracks the source.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("hosted_url")]
    public string HostedUrl { get; set; }

    /// <summary>
    /// VcsURL is the URL of the VCS repository for git/path dependencies (for packages fetched
    /// from version control systems like Git)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("vcs_url")]
    public string VcsUrl { get; set; }

    /// <summary>
    /// Executables are the map of .NET Portable Executable files within this package with their
    /// version resources
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("executables")]
    public Dictionary<string, ExecutableValue> Executables { get; set; }

    /// <summary>
    /// HashPath is the relative path to the .nupkg.sha512 hash file (e.g.
    /// "app.metrics.3.0.0.nupkg.sha512")
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("hashPath")]
    public string HashPath { get; set; }

    /// <summary>
    /// Sha512 is the SHA-512 hash of the NuGet package content WITHOUT the signed content for
    /// verification (won't match hash from NuGet API or manual calculation of .nupkg file)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("sha512")]
    public string Sha512 { get; set; }

    /// <summary>
    /// ContentHash is the hash of the package content for verification
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("contentHash")]
    public string ContentHash { get; set; }

    /// <summary>
    /// Type is the dependency type indicating how this dependency was added (Direct=explicit in
    /// project file, Transitive=pulled in by another package, Project=project reference)
    ///
    /// Type is the type of the package (e.g. "rpm", "deb", "apk", etc.)
    ///
    /// Type is package type indicating purpose (library=reusable code, project=application,
    /// metapackage=aggregates dependencies, etc.)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("type")]
    public string Type { get; set; }

    /// <summary>
    /// AssemblyVersion is the .NET assembly version number (strong-named version)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("assemblyVersion")]
    public string AssemblyVersion { get; set; }

    /// <summary>
    /// Comments are additional comments or description embedded in PE resources
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("comments")]
    public string Comments { get; set; }

    /// <summary>
    /// CompanyName is the company that produced the file
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("companyName")]
    public string CompanyName { get; set; }

    /// <summary>
    /// InternalName is the internal name of the file
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("internalName")]
    public string InternalName { get; set; }

    /// <summary>
    /// LegalCopyright is the copyright notice string
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("legalCopyright")]
    public string LegalCopyright { get; set; }

    /// <summary>
    /// ProductName is the name of the product this file is part of
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("productName")]
    public string ProductName { get; set; }

    /// <summary>
    /// ProductVersion is the version of the product (may differ from AssemblyVersion)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("productVersion")]
    public string ProductVersion { get; set; }

    /// <summary>
    /// PreDepends are the packages that must be installed and configured BEFORE even starting
    /// installation of this package (stronger than Depends, discouraged unless absolutely
    /// necessary as it adds strict constraints for apt)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("preDepends")]
    public string[] PreDepends { get; set; }

    /// <summary>
    /// Source is the source package name this binary was built from (one source can produce
    /// multiple binary packages)
    ///
    /// Source is the source repository information for development (typically git repo, used
    /// when passing --prefer-source). Originates from source code repository.
    ///
    /// Source is the source registry or repository where this crate came from
    ///
    /// Source is the source registry or repository URL in format
    /// "registry+https://github.com/rust-lang/crates.io-index" for registry packages
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("source")]
    public SourceUnion? Source { get; set; }

    /// <summary>
    /// SourceVersion is the source package version (may differ from binary version when binNMU
    /// rebuilds occur)
    ///
    /// SourceVersion is the source code version identifier
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("sourceVersion")]
    public string SourceVersion { get; set; }

    /// <summary>
    /// Commit is the commit hash of the source repository for which the binary was built from
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("commit")]
    public string Commit { get; set; }

    /// <summary>
    /// OS is the OS name, typically corresponding to ID in os-release (e.g. "fedora")
    ///
    /// OperatingSystem is the target OS for build constraints (e.g., "linux", "darwin",
    /// "windows").
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("os")]
    public string Os { get; set; }

    /// <summary>
    /// OSCPE is a CPE name for the OS, typically corresponding to CPE_NAME in os-release (e.g.
    /// cpe:/o:fedoraproject:fedora:33)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("osCPE")]
    public string OsCpe { get; set; }

    /// <summary>
    /// osVersion is the version of the OS, typically corresponding to VERSION_ID in os-release
    /// (e.g. "33")
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("osVersion")]
    public string OsVersion { get; set; }

    /// <summary>
    /// SourceRepo is the URL to the source repository for which the binary was built from
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("sourceRepo")]
    public string SourceRepo { get; set; }

    /// <summary>
    /// System is a context-specific name for the system that the binary package is intended to
    /// run on or a part of
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("system")]
    public string System { get; set; }

    /// <summary>
    /// Vendor is the individual or organization that produced the source code for the binary
    ///
    /// Vendor is the organization that packaged the software.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("vendor")]
    public string Vendor { get; set; }

    /// <summary>
    /// PkgHash is the outer checksum (SHA-256) of the entire Hex package tarball for integrity
    /// verification (preferred method, replaces deprecated inner checksum)
    ///
    /// PkgHash is the outer checksum (SHA-256) of the entire Hex package tarball for integrity
    /// verification (preferred method over deprecated inner checksum)
    ///
    /// PkgHash is the package content hash for verification
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("pkgHash")]
    public string PkgHash { get; set; }

    /// <summary>
    /// PkgHashExt is the extended package hash format (inner checksum is deprecated - SHA-256 of
    /// concatenated file contents excluding CHECKSUM file, now replaced by outer checksum)
    ///
    /// PkgHashExt is the extended package hash format (inner checksum deprecated - was SHA-256
    /// of concatenated file contents)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("pkgHashExt")]
    public string PkgHashExt { get; set; }

    /// <summary>
    /// Comment is the inline comment associated with this uses statement
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("comment")]
    public string Comment { get; set; }

    /// <summary>
    /// Value is the action reference (e.g. "actions/checkout@v3")
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("value")]
    public string Value { get; set; }

    /// <summary>
    /// BuildSettings contains the Go build settings and flags used to compile the binary (e.g.,
    /// GOARCH, GOOS, CGO_ENABLED).
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("goBuildSettings")]
    public VersionResourceElement[] GoBuildSettings { get; set; }

    /// <summary>
    /// GoCompiledVersion is the version of Go used to compile the binary.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("goCompiledVersion")]
    public string GoCompiledVersion { get; set; }

    /// <summary>
    /// GoCryptoSettings contains FIPS and cryptographic configuration settings if present.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("goCryptoSettings")]
    public string[] GoCryptoSettings { get; set; }

    /// <summary>
    /// GoExperiments lists experimental Go features enabled during compilation (e.g., "arenas",
    /// "cgocheck2").
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("goExperiments")]
    public string[] GoExperiments { get; set; }

    /// <summary>
    /// H1Digest is the Go module hash in h1: format for the main module from go.sum.
    ///
    /// H1Digest is the Go module hash in h1: format from go.sum for verifying module contents.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("h1Digest")]
    public string H1Digest { get; set; }

    /// <summary>
    /// MainModule is the main module path for the binary (e.g., "github.com/anchore/syft").
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("mainModule")]
    public string MainModule { get; set; }

    /// <summary>
    /// BuildTags are the build tags used to conditionally compile code (e.g.,
    /// "integration,debug").
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("buildTags")]
    public string BuildTags { get; set; }

    /// <summary>
    /// CgoEnabled indicates whether CGO was enabled for this package.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("cgoEnabled")]
    public bool? CgoEnabled { get; set; }

    /// <summary>
    /// SnapshotURL is the URL to the Stack snapshot this package came from
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("snapshotURL")]
    public string SnapshotUrl { get; set; }

    /// <summary>
    /// Tap is Homebrew tap this formula belongs to (e.g. "homebrew/core")
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("tap")]
    public string Tap { get; set; }

    /// <summary>
    /// ArchiveDigests is cryptographic hashes of the archive file
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("digest")]
    public DigestElement[] Digest { get; set; }

    /// <summary>
    /// Manifest is parsed META-INF/MANIFEST.MF contents
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("manifest")]
    public Manifest Manifest { get; set; }

    /// <summary>
    /// PomProject is parsed pom.xml file contents
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("pomProject")]
    public PomProject PomProject { get; set; }

    /// <summary>
    /// PomProperties is parsed pom.properties file contents
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("pomProperties")]
    public PomProperties PomProperties { get; set; }

    /// <summary>
    /// VirtualPath is path within the archive hierarchy, where nested entries are delimited with
    /// ':' (for nested JARs)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("virtualPath")]
    public string VirtualPath { get; set; }

    /// <summary>
    /// Release is JVM release information and version details
    ///
    /// Release is the package release number or distribution-specific version suffix.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("release")]
    public ReleaseUnion? Release { get; set; }

    /// <summary>
    /// Author is package author name
    ///
    /// Author is who built the kernel
    ///
    /// Author is module author name and email
    ///
    /// Author is the package author name from the Author field.
    ///
    /// Author is package author(s)
    ///
    /// Author is author name
    ///
    /// Author is plugin author name
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("author")]
    public string Author { get; set; }

    /// <summary>
    /// Private is whether this is a private package
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("private")]
    public bool? Private { get; set; }

    /// <summary>
    /// Integrity is Subresource Integrity hash for verification using standard SRI format
    /// (sha512-... or sha1-...). npm changed from SHA-1 to SHA-512 in newer versions. For
    /// registry sources this is the integrity from registry, for remote tarballs it's SHA-512 of
    /// the file. npm verifies tarball matches this hash before unpacking, throwing EINTEGRITY
    /// error if mismatch detected.
    ///
    /// Integrity is Subresource Integrity hash for verification (SRI format)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("integrity")]
    public string Integrity { get; set; }

    /// <summary>
    /// Resolved is URL where this package was downloaded from (registry source)
    ///
    /// Resolved is URL where this package was downloaded from
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("resolved")]
    public string Resolved { get; set; }

    /// <summary>
    /// BuildTime is when the kernel was built
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("buildTime")]
    public string BuildTime { get; set; }

    /// <summary>
    /// ExtendedVersion is additional version information
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("extendedVersion")]
    public string ExtendedVersion { get; set; }

    /// <summary>
    /// Format is kernel image format (e.g. bzImage, zImage)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("format")]
    public string Format { get; set; }

    /// <summary>
    /// RootDevice is root device number
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("rootDevice")]
    public long? RootDevice { get; set; }

    /// <summary>
    /// RWRootFS is whether root filesystem is mounted read-write
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("rwRootFS")]
    public bool? RwRootFs { get; set; }

    /// <summary>
    /// SwapDevice is swap device number
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("swapDevice")]
    public long? SwapDevice { get; set; }

    /// <summary>
    /// VideoMode is default video mode setting
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("videoMode")]
    public string VideoMode { get; set; }

    /// <summary>
    /// KernelVersion is kernel version this module was built for
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("kernelVersion")]
    public string KernelVersion { get; set; }

    /// <summary>
    /// Parameters are the module parameters that can be configured at load time (user-settable
    /// values like module options)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("parameters")]
    public Dictionary<string, ParameterValue> Parameters { get; set; }

    /// <summary>
    /// VersionMagic is version magic string for compatibility checking (includes kernel version,
    /// SMP status, module loading capabilities like "3.17.4-302.fc21.x86_64 SMP mod_unload
    /// modversions"). Module will NOT load if vermagic doesn't match running kernel.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("versionMagic")]
    public string VersionMagic { get; set; }

    /// <summary>
    /// Dependencies are the map of dependency names to version constraints
    ///
    /// Dependencies are the list of required dependencies
    ///
    /// Dependencies are the dependency specifications, without environment qualifiers
    ///
    /// Dependencies are the package's runtime dependencies with version constraints.
    ///
    /// Dependencies are the list of dependencies with version constraints
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("dependencies")]
    public Dependencies? Dependencies { get; set; }

    /// <summary>
    /// Kb is Knowledge Base article number (e.g. "5001028")
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("kb")]
    public string Kb { get; set; }

    /// <summary>
    /// ProductID is MSRC Product ID (e.g. "Windows 10 Version 1703 for 32-bit Systems")
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("product_id")]
    public string ProductId { get; set; }

    /// <summary>
    /// Derivation is information about the .drv file that describes how this package was built
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("derivation")]
    public Derivation Derivation { get; set; }

    /// <summary>
    /// Output is the specific output name for multi-output packages (empty string for default
    /// "out" output, can be "bin", "dev", "doc", etc.)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("output")]
    public string Output { get; set; }

    /// <summary>
    /// OutputHash is hash prefix of the store path basename (first part before the dash)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("outputHash")]
    public string OutputHash { get; set; }

    /// <summary>
    /// Licenses are the list of applicable licenses
    ///
    /// Licenses is license string which may be an expression (e.g. "GPL-2 OR Apache-2.0")
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("licenses")]
    public Checksum? Licenses { get; set; }

    /// <summary>
    /// VersionResources contains key-value pairs extracted from the PE file's version resource
    /// section (e.g., FileVersion, ProductName, CompanyName).
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("VersionResources")]
    public VersionResourceElement[] VersionResources { get; set; }

    /// <summary>
    /// Authors are the list of package authors with name/email/homepage
    ///
    /// Authors are the list of gem authors (stored as array regardless of using `author` or
    /// `authors` method in gemspec)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("authors")]
    public Author[] Authors { get; set; }

    /// <summary>
    /// Bin is the list of binary/executable files that should be added to PATH
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("bin")]
    public string[] Bin { get; set; }

    /// <summary>
    /// Dist is distribution archive information for production (typically zip/tar, default
    /// install method). Packaged version of released code.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("dist")]
    public Dist Dist { get; set; }

    /// <summary>
    /// Keywords are the list of keywords for package discovery/search
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("keywords")]
    public string[] Keywords { get; set; }

    /// <summary>
    /// NotificationURL is the URL to notify when package is installed (for tracking/statistics)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("notification-url")]
    public string NotificationUrl { get; set; }

    /// <summary>
    /// Provide is virtual packages/functionality provided by this package (allows other packages
    /// to depend on capabilities)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("provide")]
    public Dictionary<string, string> Provide { get; set; }

    /// <summary>
    /// Require is runtime dependencies with version constraints (package will not install unless
    /// these requirements can be met)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("require")]
    public Dictionary<string, string> Require { get; set; }

    /// <summary>
    /// RequireDev is development-only dependencies (not installed in production, only when
    /// developing this package or running tests)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("require-dev")]
    public Dictionary<string, string> RequireDev { get; set; }

    /// <summary>
    /// Suggest is optional but recommended dependencies (suggestions for packages that would
    /// extend functionality)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("suggest")]
    public Dictionary<string, string> Suggest { get; set; }

    /// <summary>
    /// Time is timestamp when this package version was released
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("time")]
    public string Time { get; set; }

    /// <summary>
    /// AuthorEmail is the package author's email address from the Author-Email field.
    ///
    /// AuthorEmail is author email address
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("authorEmail")]
    public string AuthorEmail { get; set; }

    /// <summary>
    /// DirectURLOrigin contains VCS or direct URL installation information from direct_url.json.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("directUrlOrigin")]
    public DirectUrlOrigin DirectUrlOrigin { get; set; }

    /// <summary>
    /// Platform indicates the target platform for the package (e.g., "any", "linux", "win32").
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("platform")]
    public string Platform { get; set; }

    /// <summary>
    /// ProvidesExtra lists optional feature names that can be installed via extras (e.g., "dev",
    /// "test").
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("providesExtra")]
    public string[] ProvidesExtra { get; set; }

    /// <summary>
    /// RequiresDist lists the package dependencies with version specifiers from Requires-Dist
    /// fields.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("requiresDist")]
    public string[] RequiresDist { get; set; }

    /// <summary>
    /// RequiresPython specifies the Python version requirement (e.g., ">=3.6").
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("requiresPython")]
    public string RequiresPython { get; set; }

    /// <summary>
    /// SitePackagesRootPath is the root directory path containing the package (e.g.,
    /// "/usr/lib/python3.9/site-packages").
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("sitePackagesRootPath")]
    public string SitePackagesRootPath { get; set; }

    /// <summary>
    /// TopLevelPackages are the top-level Python module names from top_level.txt file.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("topLevelPackages")]
    public string[] TopLevelPackages { get; set; }

    /// <summary>
    /// Summary provides a description of the package
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("summary")]
    public string Summary { get; set; }

    /// <summary>
    /// Extras are the optional features to install from the package (e.g., package[dev,test]).
    ///
    /// Extras are optional feature groups that include additional dependencies.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("extras")]
    public Extra[] Extras { get; set; }

    /// <summary>
    /// Markers are environment marker expressions for conditional installation (e.g.,
    /// "python_version >= '3.8'").
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("markers")]
    public string Markers { get; set; }

    /// <summary>
    /// VersionConstraint specifies version requirements.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("versionConstraint")]
    public string VersionConstraint { get; set; }

    /// <summary>
    /// Hashes are the package file hash values in the format "algorithm:digest" for integrity
    /// verification.
    ///
    /// Hashes are cryptographic checksums for the provider plugin archives across different
    /// platforms.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("hashes")]
    public string[] Hashes { get; set; }

    /// <summary>
    /// Index is the PyPI index name where the package should be fetched from.
    ///
    /// Index is the package repository name where the package should be fetched from.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("index")]
    public string Index { get; set; }

    /// <summary>
    /// Built is R version and platform this was built with
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("built")]
    public string Built { get; set; }

    /// <summary>
    /// Imports are the packages imported in the NAMESPACE
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("imports")]
    public string[] Imports { get; set; }

    /// <summary>
    /// NeedsCompilation is whether this package requires compilation
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("needsCompilation")]
    public bool? NeedsCompilation { get; set; }

    /// <summary>
    /// Suggests are the optional packages that extend functionality
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("suggests")]
    public string[] Suggests { get; set; }

    /// <summary>
    /// Title is short one-line package title
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("title")]
    public string Title { get; set; }

    [JsonPropertyName("epoch")]
    public long? Epoch { get; set; }

    /// <summary>
    /// ModularityLabel identifies the module stream for modular RPM packages (e.g.,
    /// "nodejs:12:20200101").
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("modularityLabel")]
    public string ModularityLabel { get; set; }

    /// <summary>
    /// Signatures contains GPG signature metadata for package verification.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("signatures")]
    public SignatureElement[] Signatures { get; set; }

    /// <summary>
    /// SourceRpm is the source RPM filename that was used to build this package.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("sourceRpm")]
    public string SourceRpm { get; set; }

    /// <summary>
    /// Base is the base snap name that this snap depends on (e.g., "core20", "core22").
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("base")]
    public string Base { get; set; }

    /// <summary>
    /// SnapName is the snap package name.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("snapName")]
    public string SnapName { get; set; }

    /// <summary>
    /// SnapType indicates the snap type (base, kernel, app, gadget, or snapd).
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("snapType")]
    public string SnapType { get; set; }

    /// <summary>
    /// SnapVersion is the snap package version.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("snapVersion")]
    public string SnapVersion { get; set; }

    /// <summary>
    /// PackagerEmail is packager email address
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("packagerEmail")]
    public string PackagerEmail { get; set; }

    /// <summary>
    /// Constraints specifies the version constraints for the provider (e.g., "~> 4.0").
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("constraints")]
    public string Constraints { get; set; }

    /// <summary>
    /// AuthorURI is author's website URL
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("authorUri")]
    public string AuthorUri { get; set; }

    /// <summary>
    /// PluginInstallDirectory is directory name where the plugin is installed
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("pluginInstallDirectory")]
    public string PluginInstallDirectory { get; set; }
}

/// <summary>
/// PhpComposerAuthors represents author information for a PHP Composer package from the
/// authors field in composer.json.
/// </summary>
public partial class AuthorClass
{
    /// <summary>
    /// Email is author's email address
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("email")]
    public string Email { get; set; }

    /// <summary>
    /// Homepage is author's personal or company website
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("homepage")]
    public string Homepage { get; set; }

    /// <summary>
    /// Name is author's full name
    /// </summary>
    [JsonPropertyName("name")]
    public string Name { get; set; }
}

public partial class BackupElement
{
    /// <summary>
    /// Digests contains file content hashes for integrity verification
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("digest")]
    public DigestElement[] Digest { get; set; }

    /// <summary>
    /// GID is the file owner group ID as recorded by pacman
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("gid")]
    public string Gid { get; set; }

    /// <summary>
    /// Link is the symlink target path if this is a symlink
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("link")]
    public string Link { get; set; }

    /// <summary>
    /// Path is the file path relative to the filesystem root
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("path")]
    public string Path { get; set; }

    /// <summary>
    /// Size is the file size in bytes
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("size")]
    public string Size { get; set; }

    /// <summary>
    /// Time is the file modification timestamp
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("time")]
    public DateTimeOffset? Time { get; set; }

    /// <summary>
    /// Type is the file type (e.g. regular file, directory, symlink)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("type")]
    public string Type { get; set; }

    /// <summary>
    /// UID is the file owner user ID as recorded by pacman
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("uid")]
    public string Uid { get; set; }
}

/// <summary>
/// Digest represents a cryptographic hash of file contents.
///
/// Digest is the file content hash for integrity verification
///
/// Digest is the file content hash (typically MD5 for dpkg compatibility with legacy
/// systems)
///
/// Digest is file content hash (MD5 for regular files in CONTENTS format: "obj filename
/// md5hash mtime")
///
/// Digest contains the hash algorithm and value for file integrity verification.
/// </summary>
public partial class DigestElement
{
    /// <summary>
    /// Algorithm specifies the hash algorithm used (e.g., "sha256", "md5").
    /// </summary>
    [JsonPropertyName("algorithm")]
    public string Algorithm { get; set; }

    /// <summary>
    /// Value is the hexadecimal string representation of the hash.
    /// </summary>
    [JsonPropertyName("value")]
    public string Value { get; set; }
}

/// <summary>
/// PythonPoetryLockDependencyEntry represents a single dependency entry within a Poetry lock
/// file.
///
/// PythonUvLockDependencyEntry represents a single dependency entry within a uv lock file.
/// </summary>
public partial class DependencyClass
{
    /// <summary>
    /// Extras are the optional feature names from the dependency that should be installed.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("extras")]
    public string[] Extras { get; set; }

    /// <summary>
    /// Markers are environment marker expressions that conditionally enable the dependency
    /// (e.g., "python_version >= '3.8'").
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("markers")]
    public string Markers { get; set; }

    /// <summary>
    /// Name is the dependency package name.
    /// </summary>
    [JsonPropertyName("name")]
    public string Name { get; set; }

    /// <summary>
    /// Optional indicates whether this dependency is optional (only needed for certain extras).
    /// </summary>
    [JsonPropertyName("optional")]
    public bool Optional { get; set; }

    /// <summary>
    /// Version is the locked version or version constraint for the dependency.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("version")]
    public string Version { get; set; }
}

/// <summary>
/// Derivation is information about the .drv file that describes how this package was built
///
/// NixDerivation represents a Nix .drv file that describes how to build a package including
/// inputs, outputs, and build instructions.
/// </summary>
public partial class Derivation
{
    /// <summary>
    /// InputDerivations are the list of other derivations that were inputs to this build
    /// (dependencies)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("inputDerivations")]
    public InputDerivationElement[] InputDerivations { get; set; }

    /// <summary>
    /// InputSources are the list of source file paths that were inputs to this build
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("inputSources")]
    public string[] InputSources { get; set; }

    /// <summary>
    /// Path is path to the .drv file in Nix store
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("path")]
    public string Path { get; set; }

    /// <summary>
    /// System is target system string indicating where derivation can be built (e.g.
    /// "x86_64-linux", "aarch64-darwin"). Must match current system for local builds.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("system")]
    public string System { get; set; }
}

/// <summary>
/// NixDerivationReference represents a reference to another derivation used as a build input
/// or runtime dependency.
/// </summary>
public partial class InputDerivationElement
{
    /// <summary>
    /// Outputs are which outputs of the referenced derivation were used (e.g. ["out"], ["bin",
    /// "dev"])
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("outputs")]
    public string[] Outputs { get; set; }

    /// <summary>
    /// Path is path to the referenced .drv file
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("path")]
    public string Path { get; set; }
}

/// <summary>
/// DirectURLOrigin contains VCS or direct URL installation information from
/// direct_url.json.
///
/// PythonDirectURLOriginInfo represents installation source metadata from direct_url.json
/// for packages installed from VCS or direct URLs.
/// </summary>
public partial class DirectUrlOrigin
{
    /// <summary>
    /// CommitID is the VCS commit hash if installed from version control.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("commitId")]
    public string CommitId { get; set; }

    /// <summary>
    /// URL is the source URL from which the package was installed.
    /// </summary>
    [JsonPropertyName("url")]
    public string Url { get; set; }

    /// <summary>
    /// VCS is the version control system type (e.g., "git", "hg").
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("vcs")]
    public string Vcs { get; set; }
}

/// <summary>
/// Dist is distribution archive information for production (typically zip/tar, default
/// install method). Packaged version of released code.
///
/// PhpComposerExternalReference represents source or distribution information for a PHP
/// package, indicating where the package code is retrieved from.
///
/// Source is the source repository information for development (typically git repo, used
/// when passing --prefer-source). Originates from source code repository.
/// </summary>
public partial class Dist
{
    /// <summary>
    /// Reference is git commit hash or version tag for source, or archive version for dist
    /// </summary>
    [JsonPropertyName("reference")]
    public string Reference { get; set; }

    /// <summary>
    /// Shasum is SHA hash of the archive file for integrity verification (dist only)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("shasum")]
    public string Shasum { get; set; }

    /// <summary>
    /// Type is reference type (git for source VCS, zip/tar for dist archives)
    /// </summary>
    [JsonPropertyName("type")]
    public string Type { get; set; }

    /// <summary>
    /// URL is the URL to the resource (git repository URL or archive download URL)
    /// </summary>
    [JsonPropertyName("url")]
    public string Url { get; set; }
}

/// <summary>
/// Environment is SDK version constraints for Dart and Flutter
///
/// DartPubspecEnvironment represents SDK version constraints from the environment section of
/// pubspec.yaml.
/// </summary>
public partial class Environment
{
    /// <summary>
    /// Flutter is the Flutter SDK version constraint if this is a Flutter package
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("flutter")]
    public string Flutter { get; set; }

    /// <summary>
    /// SDK is the Dart SDK version constraint
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("sdk")]
    public string Sdk { get; set; }
}

/// <summary>
/// DotnetPortableExecutableEntry is a struct that represents a single entry found within
/// "VersionResources" section of a .NET Portable Executable binary file.
/// </summary>
public partial class ExecutableValue
{
    /// <summary>
    /// AssemblyVersion is the .NET assembly version number (strong-named version)
    /// </summary>
    [JsonPropertyName("assemblyVersion")]
    public string AssemblyVersion { get; set; }

    /// <summary>
    /// Comments are additional comments or description embedded in PE resources
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("comments")]
    public string Comments { get; set; }

    /// <summary>
    /// CompanyName is the company that produced the file
    /// </summary>
    [JsonPropertyName("companyName")]
    public string CompanyName { get; set; }

    /// <summary>
    /// InternalName is the internal name of the file
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("internalName")]
    public string InternalName { get; set; }

    /// <summary>
    /// LegalCopyright is the copyright notice string
    /// </summary>
    [JsonPropertyName("legalCopyright")]
    public string LegalCopyright { get; set; }

    /// <summary>
    /// ProductName is the name of the product this file is part of
    /// </summary>
    [JsonPropertyName("productName")]
    public string ProductName { get; set; }

    /// <summary>
    /// ProductVersion is the version of the product (may differ from AssemblyVersion)
    /// </summary>
    [JsonPropertyName("productVersion")]
    public string ProductVersion { get; set; }
}

/// <summary>
/// PythonPoetryLockExtraEntry represents an optional feature group in a Poetry lock file.
///
/// PythonUvLockExtraEntry represents an optional feature group in a uv lock file.
/// </summary>
public partial class ExtraClass
{
    /// <summary>
    /// Dependencies are the package names required when this extra is installed.
    /// </summary>
    [JsonPropertyName("dependencies")]
    public string[] Dependencies { get; set; }

    /// <summary>
    /// Name is the optional feature name (e.g., "dev", "test").
    /// </summary>
    [JsonPropertyName("name")]
    public string Name { get; set; }
}

/// <summary>
/// ApkFileRecord represents a single file listing and metadata from a APK DB entry (which
/// may have many of these file records).
///
/// DpkgFileRecord represents a single file attributed to a debian package.
///
/// PortageFileRecord represents a single file attributed to a portage package.
///
/// PythonFileRecord represents a single entry within a RECORD file for a python wheel or egg
/// package
///
/// RpmFileRecord represents the file metadata for a single file attributed to a RPM package.
/// </summary>
public partial class FileFile
{
    /// <summary>
    /// Digests contains file content hashes for integrity verification
    ///
    /// Digest is the file content hash for integrity verification
    ///
    /// Digest is the file content hash (typically MD5 for dpkg compatibility with legacy
    /// systems)
    ///
    /// Digest is file content hash (MD5 for regular files in CONTENTS format: "obj filename
    /// md5hash mtime")
    ///
    /// Digest contains the hash algorithm and value for file integrity verification.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("digest")]
    public Digest? Digest { get; set; }

    /// <summary>
    /// GID is the file owner group ID as recorded by pacman
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("gid")]
    public string Gid { get; set; }

    /// <summary>
    /// Link is the symlink target path if this is a symlink
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("link")]
    public string Link { get; set; }

    /// <summary>
    /// Path is the file path relative to the filesystem root
    ///
    /// Path is the installed file path from the RECORD file.
    ///
    /// Path is the absolute file path where the file is installed.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("path")]
    public string Path { get; set; }

    /// <summary>
    /// Size is the file size in bytes
    ///
    /// Size is the file size in bytes as a string.
    ///
    /// Size is the file size in bytes.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("size")]
    public Timestamp? Size { get; set; }

    /// <summary>
    /// Time is the file modification timestamp
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("time")]
    public DateTimeOffset? Time { get; set; }

    /// <summary>
    /// Type is the file type (e.g. regular file, directory, symlink)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("type")]
    public string Type { get; set; }

    /// <summary>
    /// UID is the file owner user ID as recorded by pacman
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("uid")]
    public string Uid { get; set; }

    /// <summary>
    /// OwnerGID is the file owner group ID
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("ownerGid")]
    public string OwnerGid { get; set; }

    /// <summary>
    /// OwnerUID is the file owner user ID
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("ownerUid")]
    public string OwnerUid { get; set; }

    /// <summary>
    /// Permissions is the file permission mode string (e.g. "0755", "0644")
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("permissions")]
    public string Permissions { get; set; }

    /// <summary>
    /// IsConfigFile is whether this file is marked as a configuration file (dpkg will preserve
    /// user modifications during upgrades)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("isConfigFile")]
    public bool? IsConfigFile { get; set; }

    /// <summary>
    /// Flags indicates the file type (e.g., "%config", "%doc", "%ghost").
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("flags")]
    public string Flags { get; set; }

    /// <summary>
    /// GroupName is the group name for the file.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("groupName")]
    public string GroupName { get; set; }

    /// <summary>
    /// Mode is the file permission mode bits following Unix stat.h conventions.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("mode")]
    public long? Mode { get; set; }

    /// <summary>
    /// UserName is the owner username for the file.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("userName")]
    public string UserName { get; set; }
}

/// <summary>
/// Digest represents a cryptographic hash of file contents.
///
/// Digest is the file content hash for integrity verification
///
/// Digest is the file content hash (typically MD5 for dpkg compatibility with legacy
/// systems)
///
/// Digest is file content hash (MD5 for regular files in CONTENTS format: "obj filename
/// md5hash mtime")
///
/// Digest contains the hash algorithm and value for file integrity verification.
///
/// PythonFileDigest represents the file metadata for a single file attributed to a python
/// package.
/// </summary>
public partial class PurpleSyftOutput
{
    /// <summary>
    /// Algorithm specifies the hash algorithm used (e.g., "sha256", "md5").
    ///
    /// Algorithm is the hash algorithm used (e.g., "sha256").
    /// </summary>
    [JsonPropertyName("algorithm")]
    public string Algorithm { get; set; }

    /// <summary>
    /// Value is the hexadecimal string representation of the hash.
    ///
    /// Value is the hex-encoded hash digest value.
    /// </summary>
    [JsonPropertyName("value")]
    public string Value { get; set; }
}

/// <summary>
/// Options are package configuration options as key-value pairs (e.g. shared=True,
/// fPIC=True)
///
/// KeyValues represents an ordered collection of key-value pairs that preserves insertion
/// order.
///
/// KeyValue represents a single key-value pair.
/// </summary>
public partial class VersionResourceElement
{
    /// <summary>
    /// Key is the key name
    /// </summary>
    [JsonPropertyName("key")]
    public string Key { get; set; }

    /// <summary>
    /// Value is the value associated with the key
    /// </summary>
    [JsonPropertyName("value")]
    public string Value { get; set; }
}

/// <summary>
/// Link contains installation source metadata from the link.json file.
///
/// CondaLink represents link metadata from a Conda package's link.json file describing
/// package installation source.
/// </summary>
public partial class Link
{
    /// <summary>
    /// Source is the original path where the package was extracted from cache.
    /// </summary>
    [JsonPropertyName("source")]
    public string Source { get; set; }

    /// <summary>
    /// Type indicates the link type (1 for hard link, 2 for soft link, 3 for copy).
    /// </summary>
    [JsonPropertyName("type")]
    public long Type { get; set; }
}

/// <summary>
/// Manifest is parsed META-INF/MANIFEST.MF contents
///
/// JavaManifest represents the fields of interest extracted from a Java archive's
/// META-INF/MANIFEST.MF file.
/// </summary>
public partial class Manifest
{
    /// <summary>
    /// Main is main manifest attributes as key-value pairs
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("main")]
    public VersionResourceElement[] Main { get; set; }

    /// <summary>
    /// Sections are the named sections from the manifest (e.g. per-entry attributes)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("sections")]
    public VersionResourceElement[][] Sections { get; set; }
}

/// <summary>
/// ClassifierMatch represents a single matched value within a binary file and the "class"
/// name the search pattern represents.
/// </summary>
public partial class MatchElement
{
    [JsonPropertyName("classifier")]
    public string Classifier { get; set; }

    [JsonPropertyName("location")]
    public LocationElement Location { get; set; }
}

/// <summary>
/// LinuxKernelModuleParameter represents a configurable parameter for a kernel module with
/// its type and description.
/// </summary>
public partial class ParameterValue
{
    /// <summary>
    /// Description is a human-readable parameter description explaining what the parameter
    /// controls
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("description")]
    public string Description { get; set; }

    /// <summary>
    /// Type is parameter data type (e.g. int, string, bool, array types)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("type")]
    public string Type { get; set; }
}

/// <summary>
/// PathsData contains detailed file metadata from the paths.json file.
///
/// CondaPathsData represents the paths.json file structure from a Conda package containing
/// file metadata.
/// </summary>
public partial class PathsData
{
    /// <summary>
    /// Paths is the list of file metadata entries for all files in the package.
    /// </summary>
    [JsonPropertyName("paths")]
    public PathElement[] Paths { get; set; }

    /// <summary>
    /// PathsVersion is the schema version of the paths data format.
    /// </summary>
    [JsonPropertyName("paths_version")]
    public long PathsVersion { get; set; }
}

/// <summary>
/// CondaPathData represents metadata for a single file within a Conda package from the
/// paths.json file.
/// </summary>
public partial class PathElement
{
    /// <summary>
    /// Path is the file path relative to the Conda environment root.
    /// </summary>
    [JsonPropertyName("_path")]
    public string Path { get; set; }

    /// <summary>
    /// PathType indicates the link type for the file (e.g., "hardlink", "softlink", "directory").
    /// </summary>
    [JsonPropertyName("path_type")]
    public string PathType { get; set; }

    /// <summary>
    /// SHA256 is the SHA-256 hash of the file contents.
    /// </summary>
    [JsonPropertyName("sha256")]
    public string Sha256 { get; set; }

    /// <summary>
    /// SHA256InPrefix is the SHA-256 hash of the file after prefix replacement during
    /// installation.
    /// </summary>
    [JsonPropertyName("sha256_in_prefix")]
    public string Sha256InPrefix { get; set; }

    /// <summary>
    /// SizeInBytes is the file size in bytes.
    /// </summary>
    [JsonPropertyName("size_in_bytes")]
    public long SizeInBytes { get; set; }
}

/// <summary>
/// PomProject is parsed pom.xml file contents
///
/// JavaPomProject represents fields of interest extracted from a Java archive's pom.xml file.
/// </summary>
public partial class PomProject
{
    /// <summary>
    /// ArtifactID is Maven artifact identifier (project name)
    /// </summary>
    [JsonPropertyName("artifactId")]
    public string ArtifactId { get; set; }

    /// <summary>
    /// Description is detailed project description
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("description")]
    public string Description { get; set; }

    /// <summary>
    /// GroupID is Maven group identifier (reversed domain name like org.apache.maven)
    /// </summary>
    [JsonPropertyName("groupId")]
    public string GroupId { get; set; }

    /// <summary>
    /// Name is a human-readable project name (displayed in Maven-generated documentation)
    /// </summary>
    [JsonPropertyName("name")]
    public string Name { get; set; }

    /// <summary>
    /// Parent is the parent POM reference for inheritance (child POMs inherit configuration from
    /// parent)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("parent")]
    public Parent Parent { get; set; }

    /// <summary>
    /// Path is path to the pom.xml file within the archive
    /// </summary>
    [JsonPropertyName("path")]
    public string Path { get; set; }

    /// <summary>
    /// URL is the project URL (typically project website or repository)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("url")]
    public string Url { get; set; }

    /// <summary>
    /// Version is project version (together with groupId and artifactId forms Maven coordinates
    /// groupId:artifactId:version)
    /// </summary>
    [JsonPropertyName("version")]
    public string Version { get; set; }
}

/// <summary>
/// Parent is the parent POM reference for inheritance (child POMs inherit configuration from
/// parent)
///
/// JavaPomParent contains the fields within the parent tag in a pom.xml file
/// </summary>
public partial class Parent
{
    /// <summary>
    /// ArtifactID is the parent Maven artifact identifier
    /// </summary>
    [JsonPropertyName("artifactId")]
    public string ArtifactId { get; set; }

    /// <summary>
    /// GroupID is the parent Maven group identifier
    /// </summary>
    [JsonPropertyName("groupId")]
    public string GroupId { get; set; }

    /// <summary>
    /// Version is the parent version (child inherits configuration from this specific version of
    /// parent POM)
    /// </summary>
    [JsonPropertyName("version")]
    public string Version { get; set; }
}

/// <summary>
/// PomProperties is parsed pom.properties file contents
///
/// JavaPomProperties represents the fields of interest extracted from a Java archive's
/// pom.properties file.
/// </summary>
public partial class PomProperties
{
    /// <summary>
    /// ArtifactID is Maven artifact identifier, the name of the jar/artifact (unique within the
    /// groupId scope)
    /// </summary>
    [JsonPropertyName("artifactId")]
    public string ArtifactId { get; set; }

    /// <summary>
    /// Extra is additional custom properties not in standard Maven coordinates
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("extraFields")]
    public Dictionary<string, string> ExtraFields { get; set; }

    /// <summary>
    /// GroupID is Maven group identifier uniquely identifying the project across all projects
    /// (follows reversed domain name convention like com.company.project)
    /// </summary>
    [JsonPropertyName("groupId")]
    public string GroupId { get; set; }

    /// <summary>
    /// Name is the project name
    /// </summary>
    [JsonPropertyName("name")]
    public string Name { get; set; }

    /// <summary>
    /// Path is path to the pom.properties file within the archive
    /// </summary>
    [JsonPropertyName("path")]
    public string Path { get; set; }

    /// <summary>
    /// Scope is dependency scope determining when dependency is available (compile=default all
    /// phases, test=test compilation/execution only, runtime=runtime and test not compile,
    /// provided=expected from JDK or container)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("scope")]
    public string Scope { get; set; }

    /// <summary>
    /// Version is artifact version
    /// </summary>
    [JsonPropertyName("version")]
    public string Version { get; set; }
}

/// <summary>
/// Release is JVM release information and version details
///
/// JavaVMRelease represents JVM version and build information extracted from the release
/// file in a Java installation.
/// </summary>
public partial class ReleaseClass
{
    /// <summary>
    /// BuildInfo contains additional build information
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("buildInfo")]
    public string BuildInfo { get; set; }

    /// <summary>
    /// BuildSource Git SHA of the build repository
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("buildSource")]
    public string BuildSource { get; set; }

    /// <summary>
    /// BuildSourceRepo refers to rhe repository URL for the build source
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("buildSourceRepo")]
    public string BuildSourceRepo { get; set; }

    /// <summary>
    /// BuildType can be 'commercial' (used in some older oracle JDK distributions)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("buildType")]
    public string BuildType { get; set; }

    /// <summary>
    /// FullVersion is extracted from the 'java.runtime.version' JVM property
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("fullVersion")]
    public string FullVersion { get; set; }

    /// <summary>
    /// ImageType can be 'JDK' or 'JRE'
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("imageType")]
    public string ImageType { get; set; }

    /// <summary>
    /// Implementor is extracted with the `java.vendor` JVM property
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("implementor")]
    public string Implementor { get; set; }

    /// <summary>
    /// ImplementorVersion is extracted with the `java.vendor.version` JVM property
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("implementorVersion")]
    public string ImplementorVersion { get; set; }

    /// <summary>
    /// JavaRuntimeVersion is extracted from the 'java.runtime.version' JVM property
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("javaRuntimeVersion")]
    public string JavaRuntimeVersion { get; set; }

    /// <summary>
    /// JavaVersion matches that from `java -version` command output
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("javaVersion")]
    public string JavaVersion { get; set; }

    /// <summary>
    /// JavaVersionDate is extracted from the 'java.version.date' JVM property
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("javaVersionDate")]
    public string JavaVersionDate { get; set; }

    /// <summary>
    /// JvmVariant specifies the JVM variant (e.g., Hotspot or OpenJ9)
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("jvmVariant")]
    public string JvmVariant { get; set; }

    /// <summary>
    /// JvmVersion is extracted from the 'java.vm.version' JVM property
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("jvmVersion")]
    public string JvmVersion { get; set; }

    /// <summary>
    /// Libc can either be 'glibc' or 'musl'
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("libc")]
    public string Libc { get; set; }

    /// <summary>
    /// Modules is a list of JVM modules that are packaged
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("modules")]
    public string[] Modules { get; set; }

    /// <summary>
    /// OsArch is the target CPU architecture
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("osArch")]
    public string OsArch { get; set; }

    /// <summary>
    /// OsName is the name of the target runtime operating system environment
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("osName")]
    public string OsName { get; set; }

    /// <summary>
    /// OsVersion is the version of the target runtime operating system environment
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("osVersion")]
    public string OsVersion { get; set; }

    /// <summary>
    /// SemanticVersion is derived from the OpenJDK version
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("semanticVersion")]
    public string SemanticVersion { get; set; }

    /// <summary>
    /// Source refers to the origin repository of OpenJDK source
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("source")]
    public string Source { get; set; }

    /// <summary>
    /// SourceRepo refers to the OpenJDK repository URL
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("sourceRepo")]
    public string SourceRepo { get; set; }
}

/// <summary>
/// RpmSignature represents a GPG signature for an RPM package used for authenticity
/// verification.
/// </summary>
public partial class SignatureElement
{
    /// <summary>
    /// PublicKeyAlgorithm is the public key algorithm used for signing (e.g., "RSA").
    /// </summary>
    [JsonPropertyName("algo")]
    public string Algo { get; set; }

    /// <summary>
    /// Created is the timestamp when the signature was created.
    /// </summary>
    [JsonPropertyName("created")]
    public string Created { get; set; }

    /// <summary>
    /// HashAlgorithm is the hash algorithm used for the signature (e.g., "SHA256").
    /// </summary>
    [JsonPropertyName("hash")]
    public string Hash { get; set; }

    /// <summary>
    /// IssuerKeyID is the GPG key ID that created the signature.
    /// </summary>
    [JsonPropertyName("issuer")]
    public string Issuer { get; set; }
}

/// <summary>
/// Descriptor describes what created the document as well as surrounding metadata
/// </summary>
public partial class Descriptor
{
    [JsonPropertyName("configuration")]
    public object Configuration { get; set; }

    [JsonPropertyName("name")]
    public string Name { get; set; }

    [JsonPropertyName("version")]
    public string Version { get; set; }
}

public partial class Distro
{
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("bugReportURL")]
    public string BugReportUrl { get; set; }

    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("buildID")]
    public string BuildId { get; set; }

    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("cpeName")]
    public string CpeName { get; set; }

    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("extendedSupport")]
    public bool? ExtendedSupport { get; set; }

    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("homeURL")]
    public string HomeUrl { get; set; }

    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("id")]
    public string Id { get; set; }

    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("idLike")]
    public string[] IdLike { get; set; }

    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("imageID")]
    public string ImageId { get; set; }

    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("imageVersion")]
    public string ImageVersion { get; set; }

    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("name")]
    public string Name { get; set; }

    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("prettyName")]
    public string PrettyName { get; set; }

    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("privacyPolicyURL")]
    public string PrivacyPolicyUrl { get; set; }

    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("supportEnd")]
    public string SupportEnd { get; set; }

    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("supportURL")]
    public string SupportUrl { get; set; }

    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("variant")]
    public string Variant { get; set; }

    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("variantID")]
    public string VariantId { get; set; }

    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("version")]
    public string Version { get; set; }

    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("versionCodename")]
    public string VersionCodename { get; set; }

    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("versionID")]
    public string VersionId { get; set; }
}

public partial class FileElement
{
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("contents")]
    public string Contents { get; set; }

    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("digests")]
    public DigestElement[] Digests { get; set; }

    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("executable")]
    public Executable Executable { get; set; }

    [JsonPropertyName("id")]
    public string Id { get; set; }

    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("licenses")]
    public FileLicense[] Licenses { get; set; }

    [JsonPropertyName("location")]
    public Location Location { get; set; }

    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("metadata")]
    public Metadata Metadata { get; set; }

    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("unknowns")]
    public string[] Unknowns { get; set; }
}

/// <summary>
/// Executable contains metadata about binary files and their security features.
/// </summary>
public partial class Executable
{
    /// <summary>
    /// ELFSecurityFeatures contains ELF-specific security hardening information when Format is
    /// ELF.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("elfSecurityFeatures")]
    public ElfSecurityFeatures ElfSecurityFeatures { get; set; }

    /// <summary>
    /// Format denotes either ELF, Mach-O, or PE
    /// </summary>
    [JsonPropertyName("format")]
    public string Format { get; set; }

    /// <summary>
    /// HasEntrypoint indicates whether the binary has an entry point function.
    /// </summary>
    [JsonPropertyName("hasEntrypoint")]
    public bool HasEntrypoint { get; set; }

    /// <summary>
    /// HasExports indicates whether the binary exports symbols.
    /// </summary>
    [JsonPropertyName("hasExports")]
    public bool HasExports { get; set; }

    /// <summary>
    /// ImportedLibraries lists the shared libraries required by this executable.
    /// </summary>
    [JsonPropertyName("importedLibraries")]
    public string[] ImportedLibraries { get; set; }
}

/// <summary>
/// ELFSecurityFeatures contains ELF-specific security hardening information when Format is
/// ELF.
///
/// ELFSecurityFeatures captures security hardening and protection mechanisms in ELF binaries.
/// </summary>
public partial class ElfSecurityFeatures
{
    /// <summary>
    /// ControlFlowIntegrity represents runtime checks to ensure a program's control flow adheres
    /// to the legal paths determined at compile time, thus protecting against various types of
    /// control-flow hijacking attacks
    /// see https://clang.llvm.org/docs/ControlFlowIntegrity.html
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("cfi")]
    public bool? Cfi { get; set; }

    /// <summary>
    /// DynamicSharedObject indicates whether the binary is a shared library.
    /// </summary>
    [JsonPropertyName("dso")]
    public bool Dso { get; set; }

    /// <summary>
    /// ClangFortifySource is a broad suite of extensions to libc aimed at catching misuses of
    /// common library functions
    /// see
    /// https://android.googlesource.com/platform//bionic/+/d192dbecf0b2a371eb127c0871f77a9caf81c4d2/docs/clang_fortify_anatomy.md
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("fortify")]
    public bool? Fortify { get; set; }

    /// <summary>
    /// NoExecutable indicates whether NX (no-execute) protection is enabled for the stack.
    /// </summary>
    [JsonPropertyName("nx")]
    public bool Nx { get; set; }

    /// <summary>
    /// PositionIndependentExecutable indicates whether the binary is compiled as PIE.
    /// </summary>
    [JsonPropertyName("pie")]
    public bool Pie { get; set; }

    /// <summary>
    /// RelocationReadOnly indicates the RELRO protection level.
    /// </summary>
    [JsonPropertyName("relRO")]
    public string RelRo { get; set; }

    /// <summary>
    /// LlvmSafeStack represents a compiler-based security mechanism that separates the stack
    /// into a safe stack for storing return addresses and other critical data, and an unsafe
    /// stack for everything else, to mitigate stack-based memory corruption errors
    /// see https://clang.llvm.org/docs/SafeStack.html
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("safeStack")]
    public bool? SafeStack { get; set; }

    /// <summary>
    /// StackCanary indicates whether stack smashing protection is enabled.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("stackCanary")]
    public bool? StackCanary { get; set; }

    /// <summary>
    /// SymbolTableStripped indicates whether debugging symbols have been removed.
    /// </summary>
    [JsonPropertyName("symbolTableStripped")]
    public bool SymbolTableStripped { get; set; }
}

public partial class FileLicense
{
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("evidence")]
    public Evidence Evidence { get; set; }

    [JsonPropertyName("spdxExpression")]
    public string SpdxExpression { get; set; }

    [JsonPropertyName("type")]
    public string Type { get; set; }

    [JsonPropertyName("value")]
    public string Value { get; set; }
}

public partial class Evidence
{
    [JsonPropertyName("confidence")]
    public long Confidence { get; set; }

    [JsonPropertyName("extent")]
    public long Extent { get; set; }

    [JsonPropertyName("offset")]
    public long Offset { get; set; }
}

/// <summary>
/// Coordinates contains the minimal information needed to describe how to find a file within
/// any possible source object (e.g.
/// </summary>
public partial class Location
{
    /// <summary>
    /// FileSystemID is an ID representing and entire filesystem. For container images, this is a
    /// layer digest. For directories or a root filesystem, this is blank.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("layerID")]
    public string LayerId { get; set; }

    /// <summary>
    /// RealPath is the canonical absolute form of the path accessed (all symbolic links have
    /// been followed and relative path components like '.' and '..' have been removed).
    /// </summary>
    [JsonPropertyName("path")]
    public string Path { get; set; }
}

public partial class Metadata
{
    [JsonPropertyName("groupID")]
    public long GroupId { get; set; }

    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("linkDestination")]
    public string LinkDestination { get; set; }

    [JsonPropertyName("mimeType")]
    public string MimeType { get; set; }

    [JsonPropertyName("mode")]
    public long Mode { get; set; }

    [JsonPropertyName("size")]
    public long Size { get; set; }

    [JsonPropertyName("type")]
    public string Type { get; set; }

    [JsonPropertyName("userID")]
    public long UserId { get; set; }
}

public partial class Schema
{
    [JsonPropertyName("url")]
    public string Url { get; set; }

    [JsonPropertyName("version")]
    public string Version { get; set; }
}

/// <summary>
/// Instead, the Supplier can be determined by the user of syft and passed as a config or
/// flag to help fulfill the NTIA minimum elements.
/// </summary>
public partial class SourceClass
{
    [JsonPropertyName("id")]
    public string Id { get; set; }

    [JsonPropertyName("metadata")]
    public object Metadata { get; set; }

    [JsonPropertyName("name")]
    public string Name { get; set; }

    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("supplier")]
    public string Supplier { get; set; }

    [JsonPropertyName("type")]
    public string Type { get; set; }

    [JsonPropertyName("version")]
    public string Version { get; set; }
}

public partial struct Author
{
    public AuthorClass AuthorClass;
    public string String;

    public static implicit operator Author(AuthorClass AuthorClass) => new Author { AuthorClass = AuthorClass };
    public static implicit operator Author(string String) => new Author { String = String };
}

public partial struct Checksum
{
    public string String;
    public string[] StringArray;

    public static implicit operator Checksum(string String) => new Checksum { String = String };
    public static implicit operator Checksum(string[] StringArray) => new Checksum { StringArray = StringArray };
}

public partial struct Dependency
{
    public DependencyClass DependencyClass;
    public string String;

    public static implicit operator Dependency(DependencyClass DependencyClass) => new Dependency { DependencyClass = DependencyClass };
    public static implicit operator Dependency(string String) => new Dependency { String = String };
}

public partial struct Dependencies
{
    public Dependency[] AnythingArray;
    public Dictionary<string, string> StringMap;

    public static implicit operator Dependencies(Dependency[] AnythingArray) => new Dependencies { AnythingArray = AnythingArray };
    public static implicit operator Dependencies(Dictionary<string, string> StringMap) => new Dependencies { StringMap = StringMap };
}

public partial struct Extra
{
    public ExtraClass ExtraClass;
    public string String;

    public static implicit operator Extra(ExtraClass ExtraClass) => new Extra { ExtraClass = ExtraClass };
    public static implicit operator Extra(string String) => new Extra { String = String };
}

public partial struct Digest
{
    public DigestElement[] DigestElementArray;
    public PurpleSyftOutput PurpleSyftOutput;

    public static implicit operator Digest(DigestElement[] DigestElementArray) => new Digest { DigestElementArray = DigestElementArray };
    public static implicit operator Digest(PurpleSyftOutput PurpleSyftOutput) => new Digest { PurpleSyftOutput = PurpleSyftOutput };
}

public partial struct Timestamp
{
    public long? Integer;
    public string String;

    public static implicit operator Timestamp(long Integer) => new Timestamp { Integer = Integer };
    public static implicit operator Timestamp(string String) => new Timestamp { String = String };
}

public partial struct File
{
    public FileFile FileFile;
    public string String;

    public static implicit operator File(FileFile FileFile) => new File { FileFile = FileFile };
    public static implicit operator File(string String) => new File { String = String };
}

public partial struct ReleaseUnion
{
    public ReleaseClass ReleaseClass;
    public string String;

    public static implicit operator ReleaseUnion(ReleaseClass ReleaseClass) => new ReleaseUnion { ReleaseClass = ReleaseClass };
    public static implicit operator ReleaseUnion(string String) => new ReleaseUnion { String = String };
}

public partial struct SourceUnion
{
    public Dist Dist;
    public string String;

    public static implicit operator SourceUnion(Dist Dist) => new SourceUnion { Dist = Dist };
    public static implicit operator SourceUnion(string String) => new SourceUnion { String = String };
}

public partial class SyftOutput
{
    public static SyftOutput FromJson(string json) => JsonSerializer.Deserialize<SyftOutput>(json, Microsoft.ComponentDetection.Detectors.Linux.Contracts.Converter.Settings);
}

public static class Serialize
{
    public static string ToJson(this SyftOutput self) => JsonSerializer.Serialize(self, Microsoft.ComponentDetection.Detectors.Linux.Contracts.Converter.Settings);
}

internal static class Converter
{
    public static readonly JsonSerializerOptions Settings = new(JsonSerializerDefaults.General)
    {
        Converters =
            {
                AuthorConverter.Singleton,
                ChecksumConverter.Singleton,
                DependenciesConverter.Singleton,
                DependencyConverter.Singleton,
                ExtraConverter.Singleton,
                FileConverter.Singleton,
                DigestConverter.Singleton,
                TimestampConverter.Singleton,
                ReleaseUnionConverter.Singleton,
                SourceUnionConverter.Singleton,
                new DateOnlyConverter(),
                new TimeOnlyConverter(),
                IsoDateTimeOffsetConverter.Singleton
            },
    };
}

internal class AuthorConverter : JsonConverter<Author>
{
    public override bool CanConvert(Type t) => t == typeof(Author);

    public override Author Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        switch (reader.TokenType)
        {
            case JsonTokenType.String:
                var stringValue = reader.GetString();
                return new Author { String = stringValue };
            case JsonTokenType.StartObject:
                var objectValue = JsonSerializer.Deserialize<AuthorClass>(ref reader, options);
                return new Author { AuthorClass = objectValue };
        }
        throw new Exception("Cannot unmarshal type Author");
    }

    public override void Write(Utf8JsonWriter writer, Author value, JsonSerializerOptions options)
    {
        if (value.String != null)
        {
            JsonSerializer.Serialize(writer, value.String, options);
            return;
        }
        if (value.AuthorClass != null)
        {
            JsonSerializer.Serialize(writer, value.AuthorClass, options);
            return;
        }
        throw new Exception("Cannot marshal type Author");
    }

    public static readonly AuthorConverter Singleton = new AuthorConverter();
}

internal class ChecksumConverter : JsonConverter<Checksum>
{
    public override bool CanConvert(Type t) => t == typeof(Checksum);

    public override Checksum Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        switch (reader.TokenType)
        {
            case JsonTokenType.String:
                var stringValue = reader.GetString();
                return new Checksum { String = stringValue };
            case JsonTokenType.StartArray:
                var arrayValue = JsonSerializer.Deserialize<string[]>(ref reader, options);
                return new Checksum { StringArray = arrayValue };
        }
        throw new Exception("Cannot unmarshal type Checksum");
    }

    public override void Write(Utf8JsonWriter writer, Checksum value, JsonSerializerOptions options)
    {
        if (value.String != null)
        {
            JsonSerializer.Serialize(writer, value.String, options);
            return;
        }
        if (value.StringArray != null)
        {
            JsonSerializer.Serialize(writer, value.StringArray, options);
            return;
        }
        throw new Exception("Cannot marshal type Checksum");
    }

    public static readonly ChecksumConverter Singleton = new ChecksumConverter();
}

internal class DependenciesConverter : JsonConverter<Dependencies>
{
    public override bool CanConvert(Type t) => t == typeof(Dependencies);

    public override Dependencies Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        switch (reader.TokenType)
        {
            case JsonTokenType.StartObject:
                var objectValue = JsonSerializer.Deserialize<Dictionary<string, string>>(ref reader, options);
                return new Dependencies { StringMap = objectValue };
            case JsonTokenType.StartArray:
                var arrayValue = JsonSerializer.Deserialize<Dependency[]>(ref reader, options);
                return new Dependencies { AnythingArray = arrayValue };
        }
        throw new Exception("Cannot unmarshal type Dependencies");
    }

    public override void Write(Utf8JsonWriter writer, Dependencies value, JsonSerializerOptions options)
    {
        if (value.AnythingArray != null)
        {
            JsonSerializer.Serialize(writer, value.AnythingArray, options);
            return;
        }
        if (value.StringMap != null)
        {
            JsonSerializer.Serialize(writer, value.StringMap, options);
            return;
        }
        throw new Exception("Cannot marshal type Dependencies");
    }

    public static readonly DependenciesConverter Singleton = new DependenciesConverter();
}

internal class DependencyConverter : JsonConverter<Dependency>
{
    public override bool CanConvert(Type t) => t == typeof(Dependency);

    public override Dependency Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        switch (reader.TokenType)
        {
            case JsonTokenType.String:
                var stringValue = reader.GetString();
                return new Dependency { String = stringValue };
            case JsonTokenType.StartObject:
                var objectValue = JsonSerializer.Deserialize<DependencyClass>(ref reader, options);
                return new Dependency { DependencyClass = objectValue };
        }
        throw new Exception("Cannot unmarshal type Dependency");
    }

    public override void Write(Utf8JsonWriter writer, Dependency value, JsonSerializerOptions options)
    {
        if (value.String != null)
        {
            JsonSerializer.Serialize(writer, value.String, options);
            return;
        }
        if (value.DependencyClass != null)
        {
            JsonSerializer.Serialize(writer, value.DependencyClass, options);
            return;
        }
        throw new Exception("Cannot marshal type Dependency");
    }

    public static readonly DependencyConverter Singleton = new DependencyConverter();
}

internal class ExtraConverter : JsonConverter<Extra>
{
    public override bool CanConvert(Type t) => t == typeof(Extra);

    public override Extra Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        switch (reader.TokenType)
        {
            case JsonTokenType.String:
                var stringValue = reader.GetString();
                return new Extra { String = stringValue };
            case JsonTokenType.StartObject:
                var objectValue = JsonSerializer.Deserialize<ExtraClass>(ref reader, options);
                return new Extra { ExtraClass = objectValue };
        }
        throw new Exception("Cannot unmarshal type Extra");
    }

    public override void Write(Utf8JsonWriter writer, Extra value, JsonSerializerOptions options)
    {
        if (value.String != null)
        {
            JsonSerializer.Serialize(writer, value.String, options);
            return;
        }
        if (value.ExtraClass != null)
        {
            JsonSerializer.Serialize(writer, value.ExtraClass, options);
            return;
        }
        throw new Exception("Cannot marshal type Extra");
    }

    public static readonly ExtraConverter Singleton = new ExtraConverter();
}

internal class FileConverter : JsonConverter<File>
{
    public override bool CanConvert(Type t) => t == typeof(File);

    public override File Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        switch (reader.TokenType)
        {
            case JsonTokenType.String:
                var stringValue = reader.GetString();
                return new File { String = stringValue };
            case JsonTokenType.StartObject:
                var objectValue = JsonSerializer.Deserialize<FileFile>(ref reader, options);
                return new File { FileFile = objectValue };
        }
        throw new Exception("Cannot unmarshal type File");
    }

    public override void Write(Utf8JsonWriter writer, File value, JsonSerializerOptions options)
    {
        if (value.String != null)
        {
            JsonSerializer.Serialize(writer, value.String, options);
            return;
        }
        if (value.FileFile != null)
        {
            JsonSerializer.Serialize(writer, value.FileFile, options);
            return;
        }
        throw new Exception("Cannot marshal type File");
    }

    public static readonly FileConverter Singleton = new FileConverter();
}

internal class DigestConverter : JsonConverter<Digest>
{
    public override bool CanConvert(Type t) => t == typeof(Digest);

    public override Digest Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        switch (reader.TokenType)
        {
            case JsonTokenType.StartObject:
                var objectValue = JsonSerializer.Deserialize<PurpleSyftOutput>(ref reader, options);
                return new Digest { PurpleSyftOutput = objectValue };
            case JsonTokenType.StartArray:
                var arrayValue = JsonSerializer.Deserialize<DigestElement[]>(ref reader, options);
                return new Digest { DigestElementArray = arrayValue };
        }
        throw new Exception("Cannot unmarshal type Digest");
    }

    public override void Write(Utf8JsonWriter writer, Digest value, JsonSerializerOptions options)
    {
        if (value.DigestElementArray != null)
        {
            JsonSerializer.Serialize(writer, value.DigestElementArray, options);
            return;
        }
        if (value.PurpleSyftOutput != null)
        {
            JsonSerializer.Serialize(writer, value.PurpleSyftOutput, options);
            return;
        }
        throw new Exception("Cannot marshal type Digest");
    }

    public static readonly DigestConverter Singleton = new DigestConverter();
}

internal class TimestampConverter : JsonConverter<Timestamp>
{
    public override bool CanConvert(Type t) => t == typeof(Timestamp);

    public override Timestamp Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        switch (reader.TokenType)
        {
            case JsonTokenType.Number:
                var integerValue = reader.GetInt64();
                return new Timestamp { Integer = integerValue };
            case JsonTokenType.String:
                var stringValue = reader.GetString();
                return new Timestamp { String = stringValue };
        }
        throw new Exception("Cannot unmarshal type Timestamp");
    }

    public override void Write(Utf8JsonWriter writer, Timestamp value, JsonSerializerOptions options)
    {
        if (value.Integer != null)
        {
            JsonSerializer.Serialize(writer, value.Integer.Value, options);
            return;
        }
        if (value.String != null)
        {
            JsonSerializer.Serialize(writer, value.String, options);
            return;
        }
        throw new Exception("Cannot marshal type Timestamp");
    }

    public static readonly TimestampConverter Singleton = new TimestampConverter();
}

internal class ReleaseUnionConverter : JsonConverter<ReleaseUnion>
{
    public override bool CanConvert(Type t) => t == typeof(ReleaseUnion);

    public override ReleaseUnion Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        switch (reader.TokenType)
        {
            case JsonTokenType.String:
                var stringValue = reader.GetString();
                return new ReleaseUnion { String = stringValue };
            case JsonTokenType.StartObject:
                var objectValue = JsonSerializer.Deserialize<ReleaseClass>(ref reader, options);
                return new ReleaseUnion { ReleaseClass = objectValue };
        }
        throw new Exception("Cannot unmarshal type ReleaseUnion");
    }

    public override void Write(Utf8JsonWriter writer, ReleaseUnion value, JsonSerializerOptions options)
    {
        if (value.String != null)
        {
            JsonSerializer.Serialize(writer, value.String, options);
            return;
        }
        if (value.ReleaseClass != null)
        {
            JsonSerializer.Serialize(writer, value.ReleaseClass, options);
            return;
        }
        throw new Exception("Cannot marshal type ReleaseUnion");
    }

    public static readonly ReleaseUnionConverter Singleton = new ReleaseUnionConverter();
}

internal class SourceUnionConverter : JsonConverter<SourceUnion>
{
    public override bool CanConvert(Type t) => t == typeof(SourceUnion);

    public override SourceUnion Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        switch (reader.TokenType)
        {
            case JsonTokenType.String:
                var stringValue = reader.GetString();
                return new SourceUnion { String = stringValue };
            case JsonTokenType.StartObject:
                var objectValue = JsonSerializer.Deserialize<Dist>(ref reader, options);
                return new SourceUnion { Dist = objectValue };
        }
        throw new Exception("Cannot unmarshal type SourceUnion");
    }

    public override void Write(Utf8JsonWriter writer, SourceUnion value, JsonSerializerOptions options)
    {
        if (value.String != null)
        {
            JsonSerializer.Serialize(writer, value.String, options);
            return;
        }
        if (value.Dist != null)
        {
            JsonSerializer.Serialize(writer, value.Dist, options);
            return;
        }
        throw new Exception("Cannot marshal type SourceUnion");
    }

    public static readonly SourceUnionConverter Singleton = new SourceUnionConverter();
}

public class DateOnlyConverter : JsonConverter<DateOnly>
{
    private readonly string serializationFormat;
    public DateOnlyConverter() : this(null) { }

    public DateOnlyConverter(string? serializationFormat)
    {
        this.serializationFormat = serializationFormat ?? "yyyy-MM-dd";
    }

    public override DateOnly Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        var value = reader.GetString();
        return DateOnly.Parse(value!);
    }

    public override void Write(Utf8JsonWriter writer, DateOnly value, JsonSerializerOptions options)
            => writer.WriteStringValue(value.ToString(serializationFormat));
}

public class TimeOnlyConverter : JsonConverter<TimeOnly>
{
    private readonly string serializationFormat;

    public TimeOnlyConverter() : this(null) { }

    public TimeOnlyConverter(string? serializationFormat)
    {
        this.serializationFormat = serializationFormat ?? "HH:mm:ss.fff";
    }

    public override TimeOnly Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        var value = reader.GetString();
        return TimeOnly.Parse(value!);
    }

    public override void Write(Utf8JsonWriter writer, TimeOnly value, JsonSerializerOptions options)
            => writer.WriteStringValue(value.ToString(serializationFormat));
}

internal class IsoDateTimeOffsetConverter : JsonConverter<DateTimeOffset>
{
    public override bool CanConvert(Type t) => t == typeof(DateTimeOffset);

    private const string DefaultDateTimeFormat = "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK";

    private DateTimeStyles _dateTimeStyles = DateTimeStyles.RoundtripKind;
    private string? _dateTimeFormat;
    private CultureInfo? _culture;

    public DateTimeStyles DateTimeStyles
    {
        get => _dateTimeStyles;
        set => _dateTimeStyles = value;
    }

    public string? DateTimeFormat
    {
        get => _dateTimeFormat ?? string.Empty;
        set => _dateTimeFormat = (string.IsNullOrEmpty(value)) ? null : value;
    }

    public CultureInfo Culture
    {
        get => _culture ?? CultureInfo.CurrentCulture;
        set => _culture = value;
    }

    public override void Write(Utf8JsonWriter writer, DateTimeOffset value, JsonSerializerOptions options)
    {
        string text;


        if ((_dateTimeStyles & DateTimeStyles.AdjustToUniversal) == DateTimeStyles.AdjustToUniversal
                || (_dateTimeStyles & DateTimeStyles.AssumeUniversal) == DateTimeStyles.AssumeUniversal)
        {
            value = value.ToUniversalTime();
        }

        text = value.ToString(_dateTimeFormat ?? DefaultDateTimeFormat, Culture);

        writer.WriteStringValue(text);
    }

    public override DateTimeOffset Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        string? dateText = reader.GetString();

        if (string.IsNullOrEmpty(dateText) == false)
        {
            if (!string.IsNullOrEmpty(_dateTimeFormat))
            {
                return DateTimeOffset.ParseExact(dateText, _dateTimeFormat, Culture, _dateTimeStyles);
            }
            else
            {
                return DateTimeOffset.Parse(dateText, Culture, _dateTimeStyles);
            }
        }
        else
        {
            return default(DateTimeOffset);
        }
    }


    public static readonly IsoDateTimeOffsetConverter Singleton = new IsoDateTimeOffsetConverter();
}
#pragma warning restore CS8618
#pragma warning restore CS8601
#pragma warning restore CS8603
